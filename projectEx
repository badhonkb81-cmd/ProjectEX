#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// Interrupt types
typedef enum {
    // Hardware interrupts
    IRQ_TIMER,
    IRQ_KEYBOARD,
    IRQ_MOUSE,
    // Software interrupts
    SWI_SYSCALL,
    SWI_ERROR,
    INTERRUPT_MAX
} interrupt_type_t;

// Interrupt handler function type
typedef void (*interrupt_handler_t)(void*);

// Interrupt handler registry
typedef struct {
    interrupt_handler_t handler;
    bool registered;
} interrupt_entry_t;

interrupt_entry_t interrupt_table[INTERRUPT_MAX];

// Context structure for handlers
typedef struct {
    int data;
    char message[64];
} context_t;

// Function prototypes
void timer_handler(void* ctx);
void keyboard_handler(void* ctx);
void mouse_handler(void* ctx);
void syscall_handler(void* ctx);
void error_handler(void* ctx);
void register_handler(interrupt_type_t type, interrupt_handler_t handler);
void trigger_interrupt(interrupt_type_t type, void* context);
void init_interrupt_system();
void simulate_hardware_interrupts();
void simulate_software_interrupts();

// Hardware interrupt handlers
void timer_handler(void* ctx) {
    context_t* context = (context_t*)ctx;
    printf("TIMER INTERRUPT: %s (Count: %d)\n", context->message, context->data);
}

void keyboard_handler(void* ctx) {
    context_t* context = (context_t*)ctx;
    printf("KEYBOARD INTERRUPT: %s (Keycode: %d)\n", context->message, context->data);
}

void mouse_handler(void* ctx) {
    context_t* context = (context_t*)ctx;
    printf("MOUSE INTERRUPT: %s (Position: %d)\n", context->message, context->data);
}

// Software interrupt handlers
void syscall_handler(void* ctx) {
    context_t* context = (context_t*)ctx;
    printf("SYSCALL INTERRUPT: %s (Code: %d)\n", context->message, context->data);
    
    if (context->data == 1) {
        printf("-> System call: Read from file\n");
    } else if (context->data == 2) {
        printf("-> System call: Write to file\n");
    }
}

void error_handler(void* ctx) {
    context_t* context = (context_t*)ctx;
    printf("ERROR INTERRUPT: %s (Error code: %d)\n", context->message, context->data);
    
    if (context->data == 404) {
        printf("-> Error: Resource not found\n");
    } else if (context->data == 500) {
        printf("-> Error: Internal server error\n");
    }
}

// Register an interrupt handler
void register_handler(interrupt_type_t type, interrupt_handler_t handler) {
    if (type < INTERRUPT_MAX) {
        interrupt_table[type].handler = handler;
        interrupt_table[type].registered = true;
        printf("Registered handler for interrupt %d\n", type);
    }
}

// Trigger an interrupt
void trigger_interrupt(interrupt_type_t type, void* context) {
    printf("\nTriggering interrupt %d...\n", type);
    
    if (type >= INTERRUPT_MAX) {
        printf("Invalid interrupt type!\n");
        return;
    }
    
    if (!interrupt_table[type].registered) {
        printf("No handler registered for interrupt %d!\n", type);
        return;
    }
    
    printf("Calling interrupt handler...\n");
    interrupt_table[type].handler(context);
}

// Initialize interrupt system
void init_interrupt_system() {
    for (int i = 0; i < INTERRUPT_MAX; i++) {
        interrupt_table[i].registered = false;
        interrupt_table[i].handler = NULL;
    }
    
    // Register hardware interrupt handlers
    register_handler(IRQ_TIMER, timer_handler);
    register_handler(IRQ_KEYBOARD, keyboard_handler);
    register_handler(IRQ_MOUSE, mouse_handler);
    
    // Register software interrupt handlers
    register_handler(SWI_SYSCALL, syscall_handler);
    register_handler(SWI_ERROR, error_handler);
}

// Simulate hardware interrupts with user input
void simulate_hardware_interrupts() {
    printf("\n=== Hardware Interrupt Simulation ===\n");
    printf("1. Timer interrupt\n");
    printf("2. Keyboard interrupt\n");
    printf("3. Mouse interrupt\n");
    printf("Choose an option (1-3): ");
    
    int choice;
    scanf("%d", &choice);
    
    context_t ctx;
    ctx.data = rand() % 100;
    
    switch (choice) {
        case 1:
            strcpy(ctx.message, "Timer tick occurred");
            trigger_interrupt(IRQ_TIMER, &ctx);
            break;
        case 2:
            strcpy(ctx.message, "Key pressed");
            trigger_interrupt(IRQ_KEYBOARD, &ctx);
            break;
        case 3:
            strcpy(ctx.message, "Mouse movement detected");
            trigger_interrupt(IRQ_MOUSE, &ctx);
            break;
        default:
            printf("Invalid choice!\n");
    }
}

// Simulate software interrupts with program events
void simulate_software_interrupts() {
    printf("\n=== Software Interrupt Simulation ===\n");
    printf("1. System call\n");
    printf("2. Error condition\n");
    printf("Choose an option (1-2): ");
    
    int choice;
    scanf("%d", &choice);
    
    context_t ctx;
    
    switch (choice) {
        case 1:
            ctx.data = 1 + rand() % 2;
            strcpy(ctx.message, "Process requested system service");
            trigger_interrupt(SWI_SYSCALL, &ctx);
            break;
        case 2:
            ctx.data = (rand() % 2) ? 404 : 500;
            strcpy(ctx.message, "Exception occurred");
            trigger_interrupt(SWI_ERROR, &ctx);
            break;
        default:
            printf("Invalid choice!\n");
    }
}

int main() {
    // Initialize interrupt system
    init_interrupt_system();
    
    while (1) {
        printf("\n=== Interrupt Simulation Menu ===\n");
        printf("1. Trigger hardware interrupt\n");
        printf("2. Trigger software interrupt\n");
        printf("3. Exit\n");
        printf("Choose an option: ");
        
        int choice;
        scanf("%d", &choice);
        
        switch (choice) {
            case 1:
                simulate_hardware_interrupts();
                break;
            case 2:
                simulate_software_interrupts();
                break;
            case 3:
                printf("Exiting...\n");
                return 0;
            default:
                printf("Invalid choice!\n");
        }
    }
    
    return 0;
}
